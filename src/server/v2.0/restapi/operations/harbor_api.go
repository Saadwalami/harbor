// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"net/http"
	"strings"

	errors "github.com/go-openapi/errors"
	loads "github.com/go-openapi/loads"
	runtime "github.com/go-openapi/runtime"
	middleware "github.com/go-openapi/runtime/middleware"
	security "github.com/go-openapi/runtime/security"
	spec "github.com/go-openapi/spec"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"github.com/goharbor/harbor/src/server/v2.0/restapi/operations/artifact"
	"github.com/goharbor/harbor/src/server/v2.0/restapi/operations/auditlog"
	"github.com/goharbor/harbor/src/server/v2.0/restapi/operations/project"
	"github.com/goharbor/harbor/src/server/v2.0/restapi/operations/repository"
	"github.com/goharbor/harbor/src/server/v2.0/restapi/operations/scan"
)

// NewHarborAPI creates a new Harbor instance
func NewHarborAPI(spec *loads.Document) *HarborAPI {
	return &HarborAPI{
		handlers:             make(map[string]map[string]http.Handler),
		formats:              strfmt.Default,
		defaultConsumes:      "application/json",
		defaultProduces:      "application/json",
		customConsumers:      make(map[string]runtime.Consumer),
		customProducers:      make(map[string]runtime.Producer),
		operationMiddlewares: make(map[string]middleware.Builder),
		ServerShutdown:       func() {},
		spec:                 spec,
		ServeError:           errors.ServeError,
		BasicAuthenticator:   security.BasicAuth,
		APIKeyAuthenticator:  security.APIKeyAuth,
		BearerAuthenticator:  security.BearerAuth,
		JSONConsumer:         runtime.JSONConsumer(),
		JSONProducer:         runtime.JSONProducer(),
		TxtProducer:          runtime.TextProducer(),
		ArtifactCopyArtifactHandler: artifact.CopyArtifactHandlerFunc(func(params artifact.CopyArtifactParams) middleware.Responder {
			return middleware.NotImplemented("operation ArtifactCopyArtifact has not yet been implemented")
		}),
		ArtifactAddLabelHandler: artifact.AddLabelHandlerFunc(func(params artifact.AddLabelParams) middleware.Responder {
			return middleware.NotImplemented("operation ArtifactAddLabel has not yet been implemented")
		}),
		ArtifactCreateTagHandler: artifact.CreateTagHandlerFunc(func(params artifact.CreateTagParams) middleware.Responder {
			return middleware.NotImplemented("operation ArtifactCreateTag has not yet been implemented")
		}),
		ArtifactDeleteArtifactHandler: artifact.DeleteArtifactHandlerFunc(func(params artifact.DeleteArtifactParams) middleware.Responder {
			return middleware.NotImplemented("operation ArtifactDeleteArtifact has not yet been implemented")
		}),
		RepositoryDeleteRepositoryHandler: repository.DeleteRepositoryHandlerFunc(func(params repository.DeleteRepositoryParams) middleware.Responder {
			return middleware.NotImplemented("operation RepositoryDeleteRepository has not yet been implemented")
		}),
		ArtifactDeleteTagHandler: artifact.DeleteTagHandlerFunc(func(params artifact.DeleteTagParams) middleware.Responder {
			return middleware.NotImplemented("operation ArtifactDeleteTag has not yet been implemented")
		}),
		ArtifactGetAdditionHandler: artifact.GetAdditionHandlerFunc(func(params artifact.GetAdditionParams) middleware.Responder {
			return middleware.NotImplemented("operation ArtifactGetAddition has not yet been implemented")
		}),
		ArtifactGetArtifactHandler: artifact.GetArtifactHandlerFunc(func(params artifact.GetArtifactParams) middleware.Responder {
			return middleware.NotImplemented("operation ArtifactGetArtifact has not yet been implemented")
		}),
		ProjectGetLogsHandler: project.GetLogsHandlerFunc(func(params project.GetLogsParams) middleware.Responder {
			return middleware.NotImplemented("operation ProjectGetLogs has not yet been implemented")
		}),
		ScanGetReportLogHandler: scan.GetReportLogHandlerFunc(func(params scan.GetReportLogParams) middleware.Responder {
			return middleware.NotImplemented("operation ScanGetReportLog has not yet been implemented")
		}),
		RepositoryGetRepositoryHandler: repository.GetRepositoryHandlerFunc(func(params repository.GetRepositoryParams) middleware.Responder {
			return middleware.NotImplemented("operation RepositoryGetRepository has not yet been implemented")
		}),
		ArtifactListArtifactsHandler: artifact.ListArtifactsHandlerFunc(func(params artifact.ListArtifactsParams) middleware.Responder {
			return middleware.NotImplemented("operation ArtifactListArtifacts has not yet been implemented")
		}),
		AuditlogListAuditLogsHandler: auditlog.ListAuditLogsHandlerFunc(func(params auditlog.ListAuditLogsParams) middleware.Responder {
			return middleware.NotImplemented("operation AuditlogListAuditLogs has not yet been implemented")
		}),
		RepositoryListRepositoriesHandler: repository.ListRepositoriesHandlerFunc(func(params repository.ListRepositoriesParams) middleware.Responder {
			return middleware.NotImplemented("operation RepositoryListRepositories has not yet been implemented")
		}),
		ArtifactListTagsHandler: artifact.ListTagsHandlerFunc(func(params artifact.ListTagsParams) middleware.Responder {
			return middleware.NotImplemented("operation ArtifactListTags has not yet been implemented")
		}),
		ArtifactRemoveLabelHandler: artifact.RemoveLabelHandlerFunc(func(params artifact.RemoveLabelParams) middleware.Responder {
			return middleware.NotImplemented("operation ArtifactRemoveLabel has not yet been implemented")
		}),
		ScanScanArtifactHandler: scan.ScanArtifactHandlerFunc(func(params scan.ScanArtifactParams) middleware.Responder {
			return middleware.NotImplemented("operation ScanScanArtifact has not yet been implemented")
		}),
		RepositoryUpdateRepositoryHandler: repository.UpdateRepositoryHandlerFunc(func(params repository.UpdateRepositoryParams) middleware.Responder {
			return middleware.NotImplemented("operation RepositoryUpdateRepository has not yet been implemented")
		}),
	}
}

/*HarborAPI These APIs provide services for manipulating Harbor project. */
type HarborAPI struct {
	spec            *loads.Document
	context         *middleware.Context
	handlers        map[string]map[string]http.Handler
	formats         strfmt.Registry
	customConsumers map[string]runtime.Consumer
	customProducers map[string]runtime.Producer
	defaultConsumes string
	defaultProduces string
	Middleware      func(middleware.Builder) http.Handler

	// operationMiddlewares middleware for operations
	operationMiddlewares map[string]middleware.Builder

	// BasicAuthenticator generates a runtime.Authenticator from the supplied basic auth function.
	// It has a default implementation in the security package, however you can replace it for your particular usage.
	BasicAuthenticator func(security.UserPassAuthentication) runtime.Authenticator
	// APIKeyAuthenticator generates a runtime.Authenticator from the supplied token auth function.
	// It has a default implementation in the security package, however you can replace it for your particular usage.
	APIKeyAuthenticator func(string, string, security.TokenAuthentication) runtime.Authenticator
	// BearerAuthenticator generates a runtime.Authenticator from the supplied bearer token auth function.
	// It has a default implementation in the security package, however you can replace it for your particular usage.
	BearerAuthenticator func(string, security.ScopedTokenAuthentication) runtime.Authenticator

	// JSONConsumer registers a consumer for a "application/json" mime type
	JSONConsumer runtime.Consumer

	// JSONProducer registers a producer for a "application/json" mime type
	JSONProducer runtime.Producer
	// TxtProducer registers a producer for a "text/plain" mime type
	TxtProducer runtime.Producer

	// ArtifactCopyArtifactHandler sets the operation handler for the copy artifact operation
	ArtifactCopyArtifactHandler artifact.CopyArtifactHandler
	// ArtifactAddLabelHandler sets the operation handler for the add label operation
	ArtifactAddLabelHandler artifact.AddLabelHandler
	// ArtifactCreateTagHandler sets the operation handler for the create tag operation
	ArtifactCreateTagHandler artifact.CreateTagHandler
	// ArtifactDeleteArtifactHandler sets the operation handler for the delete artifact operation
	ArtifactDeleteArtifactHandler artifact.DeleteArtifactHandler
	// RepositoryDeleteRepositoryHandler sets the operation handler for the delete repository operation
	RepositoryDeleteRepositoryHandler repository.DeleteRepositoryHandler
	// ArtifactDeleteTagHandler sets the operation handler for the delete tag operation
	ArtifactDeleteTagHandler artifact.DeleteTagHandler
	// ArtifactGetAdditionHandler sets the operation handler for the get addition operation
	ArtifactGetAdditionHandler artifact.GetAdditionHandler
	// ArtifactGetArtifactHandler sets the operation handler for the get artifact operation
	ArtifactGetArtifactHandler artifact.GetArtifactHandler
	// ProjectGetLogsHandler sets the operation handler for the get logs operation
	ProjectGetLogsHandler project.GetLogsHandler
	// ScanGetReportLogHandler sets the operation handler for the get report log operation
	ScanGetReportLogHandler scan.GetReportLogHandler
	// RepositoryGetRepositoryHandler sets the operation handler for the get repository operation
	RepositoryGetRepositoryHandler repository.GetRepositoryHandler
	// ArtifactListArtifactsHandler sets the operation handler for the list artifacts operation
	ArtifactListArtifactsHandler artifact.ListArtifactsHandler
	// AuditlogListAuditLogsHandler sets the operation handler for the list audit logs operation
	AuditlogListAuditLogsHandler auditlog.ListAuditLogsHandler
	// RepositoryListRepositoriesHandler sets the operation handler for the list repositories operation
	RepositoryListRepositoriesHandler repository.ListRepositoriesHandler
	// ArtifactListTagsHandler sets the operation handler for the list tags operation
	ArtifactListTagsHandler artifact.ListTagsHandler
	// ArtifactRemoveLabelHandler sets the operation handler for the remove label operation
	ArtifactRemoveLabelHandler artifact.RemoveLabelHandler
	// ScanScanArtifactHandler sets the operation handler for the scan artifact operation
	ScanScanArtifactHandler scan.ScanArtifactHandler
	// RepositoryUpdateRepositoryHandler sets the operation handler for the update repository operation
	RepositoryUpdateRepositoryHandler repository.UpdateRepositoryHandler

	// ServeError is called when an error is received, there is a default handler
	// but you can set your own with this
	ServeError func(http.ResponseWriter, *http.Request, error)

	// ServerShutdown is called when the HTTP(S) server is shut down and done
	// handling all active connections and does not accept connections any more
	ServerShutdown func()

	// Custom command line argument groups with their descriptions
	CommandLineOptionsGroups []swag.CommandLineOptionsGroup

	// User defined logger function.
	Logger func(string, ...interface{})
}

// SetDefaultProduces sets the default produces media type
func (o *HarborAPI) SetDefaultProduces(mediaType string) {
	o.defaultProduces = mediaType
}

// SetDefaultConsumes returns the default consumes media type
func (o *HarborAPI) SetDefaultConsumes(mediaType string) {
	o.defaultConsumes = mediaType
}

// SetSpec sets a spec that will be served for the clients.
func (o *HarborAPI) SetSpec(spec *loads.Document) {
	o.spec = spec
}

// DefaultProduces returns the default produces media type
func (o *HarborAPI) DefaultProduces() string {
	return o.defaultProduces
}

// DefaultConsumes returns the default consumes media type
func (o *HarborAPI) DefaultConsumes() string {
	return o.defaultConsumes
}

// Formats returns the registered string formats
func (o *HarborAPI) Formats() strfmt.Registry {
	return o.formats
}

// RegisterFormat registers a custom format validator
func (o *HarborAPI) RegisterFormat(name string, format strfmt.Format, validator strfmt.Validator) {
	o.formats.Add(name, format, validator)
}

// Validate validates the registrations in the HarborAPI
func (o *HarborAPI) Validate() error {
	var unregistered []string

	if o.JSONConsumer == nil {
		unregistered = append(unregistered, "JSONConsumer")
	}

	if o.JSONProducer == nil {
		unregistered = append(unregistered, "JSONProducer")
	}

	if o.TxtProducer == nil {
		unregistered = append(unregistered, "TxtProducer")
	}

	if o.ArtifactCopyArtifactHandler == nil {
		unregistered = append(unregistered, "artifact.CopyArtifactHandler")
	}

	if o.ArtifactAddLabelHandler == nil {
		unregistered = append(unregistered, "artifact.AddLabelHandler")
	}

	if o.ArtifactCreateTagHandler == nil {
		unregistered = append(unregistered, "artifact.CreateTagHandler")
	}

	if o.ArtifactDeleteArtifactHandler == nil {
		unregistered = append(unregistered, "artifact.DeleteArtifactHandler")
	}

	if o.RepositoryDeleteRepositoryHandler == nil {
		unregistered = append(unregistered, "repository.DeleteRepositoryHandler")
	}

	if o.ArtifactDeleteTagHandler == nil {
		unregistered = append(unregistered, "artifact.DeleteTagHandler")
	}

	if o.ArtifactGetAdditionHandler == nil {
		unregistered = append(unregistered, "artifact.GetAdditionHandler")
	}

	if o.ArtifactGetArtifactHandler == nil {
		unregistered = append(unregistered, "artifact.GetArtifactHandler")
	}

	if o.ProjectGetLogsHandler == nil {
		unregistered = append(unregistered, "project.GetLogsHandler")
	}

	if o.ScanGetReportLogHandler == nil {
		unregistered = append(unregistered, "scan.GetReportLogHandler")
	}

	if o.RepositoryGetRepositoryHandler == nil {
		unregistered = append(unregistered, "repository.GetRepositoryHandler")
	}

	if o.ArtifactListArtifactsHandler == nil {
		unregistered = append(unregistered, "artifact.ListArtifactsHandler")
	}

	if o.AuditlogListAuditLogsHandler == nil {
		unregistered = append(unregistered, "auditlog.ListAuditLogsHandler")
	}

	if o.RepositoryListRepositoriesHandler == nil {
		unregistered = append(unregistered, "repository.ListRepositoriesHandler")
	}

	if o.ArtifactListTagsHandler == nil {
		unregistered = append(unregistered, "artifact.ListTagsHandler")
	}

	if o.ArtifactRemoveLabelHandler == nil {
		unregistered = append(unregistered, "artifact.RemoveLabelHandler")
	}

	if o.ScanScanArtifactHandler == nil {
		unregistered = append(unregistered, "scan.ScanArtifactHandler")
	}

	if o.RepositoryUpdateRepositoryHandler == nil {
		unregistered = append(unregistered, "repository.UpdateRepositoryHandler")
	}

	if len(unregistered) > 0 {
		return fmt.Errorf("missing registration: %s", strings.Join(unregistered, ", "))
	}

	return nil
}

// ServeErrorFor gets a error handler for a given operation id
func (o *HarborAPI) ServeErrorFor(operationID string) func(http.ResponseWriter, *http.Request, error) {
	return o.ServeError
}

// AuthenticatorsFor gets the authenticators for the specified security schemes
func (o *HarborAPI) AuthenticatorsFor(schemes map[string]spec.SecurityScheme) map[string]runtime.Authenticator {

	return nil

}

// Authorizer returns the registered authorizer
func (o *HarborAPI) Authorizer() runtime.Authorizer {

	return nil

}

// ConsumersFor gets the consumers for the specified media types
func (o *HarborAPI) ConsumersFor(mediaTypes []string) map[string]runtime.Consumer {

	result := make(map[string]runtime.Consumer)
	for _, mt := range mediaTypes {
		switch mt {

		case "application/json":
			result["application/json"] = o.JSONConsumer

		}

		if c, ok := o.customConsumers[mt]; ok {
			result[mt] = c
		}
	}
	return result

}

// ProducersFor gets the producers for the specified media types
func (o *HarborAPI) ProducersFor(mediaTypes []string) map[string]runtime.Producer {

	result := make(map[string]runtime.Producer)
	for _, mt := range mediaTypes {
		switch mt {

		case "application/json":
			result["application/json"] = o.JSONProducer

		case "text/plain":
			result["text/plain"] = o.TxtProducer

		}

		if p, ok := o.customProducers[mt]; ok {
			result[mt] = p
		}
	}
	return result

}

// HandlerFor gets a http.Handler for the provided operation method and path
func (o *HarborAPI) HandlerFor(method, path string) (http.Handler, bool) {
	if o.handlers == nil {
		return nil, false
	}
	um := strings.ToUpper(method)
	if _, ok := o.handlers[um]; !ok {
		return nil, false
	}
	if path == "/" {
		path = ""
	}
	h, ok := o.handlers[um][path]
	return h, ok
}

// Context returns the middleware context for the harbor API
func (o *HarborAPI) Context() *middleware.Context {
	if o.context == nil {
		o.context = middleware.NewRoutableContext(o.spec, o, nil)
	}

	return o.context
}

func (o *HarborAPI) handler(operation string, next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		h := next
		if b, ok := o.operationMiddlewares[operation]; ok {
			h = b(h)
		}

		h.ServeHTTP(w, r)
	})
}

func (o *HarborAPI) initHandlerCache() {
	o.Context() // don't care about the result, just that the initialization happened

	if o.handlers == nil {
		o.handlers = make(map[string]map[string]http.Handler)
	}

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/projects/{project_name}/repositories/{repository_name}/artifacts"] = o.handler("CopyArtifact", artifact.NewCopyArtifact(o.context, o.ArtifactCopyArtifactHandler))

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/labels"] = o.handler("AddLabel", artifact.NewAddLabel(o.context, o.ArtifactAddLabelHandler))

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags"] = o.handler("CreateTag", artifact.NewCreateTag(o.context, o.ArtifactCreateTagHandler))

	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}"] = o.handler("DeleteArtifact", artifact.NewDeleteArtifact(o.context, o.ArtifactDeleteArtifactHandler))

	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/projects/{project_name}/repositories/{repository_name}"] = o.handler("DeleteRepository", repository.NewDeleteRepository(o.context, o.RepositoryDeleteRepositoryHandler))

	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags/{tag_name}"] = o.handler("DeleteTag", artifact.NewDeleteTag(o.context, o.ArtifactDeleteTagHandler))

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/additions/{addition}"] = o.handler("GetAddition", artifact.NewGetAddition(o.context, o.ArtifactGetAdditionHandler))

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}"] = o.handler("GetArtifact", artifact.NewGetArtifact(o.context, o.ArtifactGetArtifactHandler))

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/projects/{project_name}/logs"] = o.handler("GetLogs", project.NewGetLogs(o.context, o.ProjectGetLogsHandler))

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan/{report_id}/log"] = o.handler("GetReportLog", scan.NewGetReportLog(o.context, o.ScanGetReportLogHandler))

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/projects/{project_name}/repositories/{repository_name}"] = o.handler("GetRepository", repository.NewGetRepository(o.context, o.RepositoryGetRepositoryHandler))

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/projects/{project_name}/repositories/{repository_name}/artifacts"] = o.handler("ListArtifacts", artifact.NewListArtifacts(o.context, o.ArtifactListArtifactsHandler))

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/audit-logs"] = o.handler("ListAuditLogs", auditlog.NewListAuditLogs(o.context, o.AuditlogListAuditLogsHandler))

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/projects/{project_name}/repositories"] = o.handler("ListRepositories", repository.NewListRepositories(o.context, o.RepositoryListRepositoriesHandler))

	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags"] = o.handler("ListTags", artifact.NewListTags(o.context, o.ArtifactListTagsHandler))

	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/labels/{label_id}"] = o.handler("RemoveLabel", artifact.NewRemoveLabel(o.context, o.ArtifactRemoveLabelHandler))

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan"] = o.handler("ScanArtifact", scan.NewScanArtifact(o.context, o.ScanScanArtifactHandler))

	if o.handlers["PUT"] == nil {
		o.handlers["PUT"] = make(map[string]http.Handler)
	}
	o.handlers["PUT"]["/projects/{project_name}/repositories/{repository_name}"] = o.handler("UpdateRepository", repository.NewUpdateRepository(o.context, o.RepositoryUpdateRepositoryHandler))

}

// Serve creates a http handler to serve the API over HTTP
// can be used directly in http.ListenAndServe(":8000", api.Serve(nil))
func (o *HarborAPI) Serve(builder middleware.Builder) http.Handler {
	o.Init()

	if o.Middleware != nil {
		return o.Middleware(builder)
	}
	return o.context.APIHandler(builder)
}

// Init allows you to just initialize the handler cache, you can then recompose the middleware as you see fit
func (o *HarborAPI) Init() {
	if len(o.handlers) == 0 {
		o.initHandlerCache()
	}
}

// RegisterConsumer allows you to add (or override) a consumer for a media type.
func (o *HarborAPI) RegisterConsumer(mediaType string, consumer runtime.Consumer) {
	o.customConsumers[mediaType] = consumer
}

// RegisterProducer allows you to add (or override) a producer for a media type.
func (o *HarborAPI) RegisterProducer(mediaType string, producer runtime.Producer) {
	o.customProducers[mediaType] = producer
}

// RegisterMiddleware allows you to add (or override) a middleware for operation.
func (o *HarborAPI) RegisterMiddleware(operation string, builder middleware.Builder) {
	o.operationMiddlewares[operation] = builder
}
