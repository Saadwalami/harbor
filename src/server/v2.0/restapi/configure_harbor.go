// Code generated by go-swagger; DO NOT EDIT.

package restapi

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/loads"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"

	"github.com/goharbor/harbor/src/server/v2.0/restapi/operations"
	"github.com/goharbor/harbor/src/server/v2.0/restapi/operations/artifact"
	"github.com/goharbor/harbor/src/server/v2.0/restapi/operations/auditlog"
	"github.com/goharbor/harbor/src/server/v2.0/restapi/operations/project"
	"github.com/goharbor/harbor/src/server/v2.0/restapi/operations/repository"
	"github.com/goharbor/harbor/src/server/v2.0/restapi/operations/scan"
)

type contextKey string

const AuthKey contextKey = "Auth"

// go:generate mockery -name ArtifactAPI -inpkg

// ArtifactAPI
type ArtifactAPI interface {
	// Prepare action before the operation
	Prepare(ctx context.Context, operation string, params interface{}) middleware.Responder
	// CopyArtifact is Copy the artifact specified in the "from" parameter to the repository.
	CopyArtifact(ctx context.Context, params artifact.CopyArtifactParams) middleware.Responder
	// AddLabel is Add label to the specified artiact.
	AddLabel(ctx context.Context, params artifact.AddLabelParams) middleware.Responder
	// CreateTag is Create a tag for the specified artifact
	CreateTag(ctx context.Context, params artifact.CreateTagParams) middleware.Responder
	// DeleteArtifact is Delete the artifact specified by the reference under the project and repository. The reference can be digest or tag
	DeleteArtifact(ctx context.Context, params artifact.DeleteArtifactParams) middleware.Responder
	// DeleteTag is Delete the tag of the specified artifact
	DeleteTag(ctx context.Context, params artifact.DeleteTagParams) middleware.Responder
	// GetAddition is Get the addition of the artifact specified by the reference under the project and repository.
	GetAddition(ctx context.Context, params artifact.GetAdditionParams) middleware.Responder
	// GetArtifact is Get the artifact specified by the reference under the project and repository. The reference can be digest or tag.
	GetArtifact(ctx context.Context, params artifact.GetArtifactParams) middleware.Responder
	// ListArtifacts is List artifacts under the specific project and repository. Except the basic properties, the other supported queries in "q" includes "tags=*" to list only tagged artifacts, "tags=nil" to list only untagged artifacts, "tags=~v" to list artifacts whose tag fuzzy matches "v", "tags=v" to list artifact whose tag exactly matches "v", "labels=(id1, id2)" to list artifacts that both labels with id1 and id2 are added to
	ListArtifacts(ctx context.Context, params artifact.ListArtifactsParams) middleware.Responder
	// ListTags is List tags of the specific artifact
	ListTags(ctx context.Context, params artifact.ListTagsParams) middleware.Responder
	// RemoveLabel is Remove the label from the specified artiact.
	RemoveLabel(ctx context.Context, params artifact.RemoveLabelParams) middleware.Responder
}

// go:generate mockery -name AuditlogAPI -inpkg

// AuditlogAPI
type AuditlogAPI interface {
	// Prepare action before the operation
	Prepare(ctx context.Context, operation string, params interface{}) middleware.Responder
	// ListAuditLogs is This endpoint let user see the recent operation logs of the projects which he is member of

	ListAuditLogs(ctx context.Context, params auditlog.ListAuditLogsParams) middleware.Responder
}

// go:generate mockery -name ProjectAPI -inpkg

// ProjectAPI
type ProjectAPI interface {
	// Prepare action before the operation
	Prepare(ctx context.Context, operation string, params interface{}) middleware.Responder
	// GetLogs is Get recent logs of the projects
	GetLogs(ctx context.Context, params project.GetLogsParams) middleware.Responder
}

// go:generate mockery -name RepositoryAPI -inpkg

// RepositoryAPI
type RepositoryAPI interface {
	// Prepare action before the operation
	Prepare(ctx context.Context, operation string, params interface{}) middleware.Responder
	// DeleteRepository is Delete the repository specified by name
	DeleteRepository(ctx context.Context, params repository.DeleteRepositoryParams) middleware.Responder
	// GetRepository is Get the repository specified by name
	GetRepository(ctx context.Context, params repository.GetRepositoryParams) middleware.Responder
	// ListRepositories is List repositories of the specified project
	ListRepositories(ctx context.Context, params repository.ListRepositoriesParams) middleware.Responder
	// UpdateRepository is Update the repository specified by name
	UpdateRepository(ctx context.Context, params repository.UpdateRepositoryParams) middleware.Responder
}

// go:generate mockery -name ScanAPI -inpkg

// ScanAPI
type ScanAPI interface {
	// Prepare action before the operation
	Prepare(ctx context.Context, operation string, params interface{}) middleware.Responder
	// GetReportLog is Get the log of the scan report
	GetReportLog(ctx context.Context, params scan.GetReportLogParams) middleware.Responder
	// ScanArtifact is Scan the specified artifact
	ScanArtifact(ctx context.Context, params scan.ScanArtifactParams) middleware.Responder
}

// Config is configuration for Handler
type Config struct {
	ArtifactAPI
	AuditlogAPI
	ProjectAPI
	RepositoryAPI
	ScanAPI
	Logger func(string, ...interface{})
	// InnerMiddleware is for the handler executors. These do not apply to the swagger.json document.
	// The middleware executes after routing but before authentication, binding and validation
	InnerMiddleware func(http.Handler) http.Handler

	// Authorizer is used to authorize a request after the Auth function was called using the "Auth*" functions
	// and the principal was stored in the context in the "AuthKey" context value.
	Authorizer func(*http.Request) error
}

// Handler returns an http.Handler given the handler configuration
// It mounts all the business logic implementers in the right routing.
func Handler(c Config) (http.Handler, error) {
	h, _, err := HandlerAPI(c)
	return h, err
}

// HandlerAPI returns an http.Handler given the handler configuration
// and the corresponding *Harbor instance.
// It mounts all the business logic implementers in the right routing.
func HandlerAPI(c Config) (http.Handler, *operations.HarborAPI, error) {
	spec, err := loads.Analyzed(swaggerCopy(SwaggerJSON), "")
	if err != nil {
		return nil, nil, fmt.Errorf("analyze swagger: %v", err)
	}
	api := operations.NewHarborAPI(spec)
	api.ServeError = errors.ServeError
	api.Logger = c.Logger

	api.JSONConsumer = runtime.JSONConsumer()
	api.JSONProducer = runtime.JSONProducer()
	api.TxtProducer = runtime.TextProducer()
	api.ArtifactCopyArtifactHandler = artifact.CopyArtifactHandlerFunc(func(params artifact.CopyArtifactParams) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		if res := c.ArtifactAPI.Prepare(ctx, "CopyArtifact", &params); res != nil {
			return res
		}
		return c.ArtifactAPI.CopyArtifact(ctx, params)
	})
	api.ArtifactAddLabelHandler = artifact.AddLabelHandlerFunc(func(params artifact.AddLabelParams) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		if res := c.ArtifactAPI.Prepare(ctx, "AddLabel", &params); res != nil {
			return res
		}
		return c.ArtifactAPI.AddLabel(ctx, params)
	})
	api.ArtifactCreateTagHandler = artifact.CreateTagHandlerFunc(func(params artifact.CreateTagParams) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		if res := c.ArtifactAPI.Prepare(ctx, "CreateTag", &params); res != nil {
			return res
		}
		return c.ArtifactAPI.CreateTag(ctx, params)
	})
	api.ArtifactDeleteArtifactHandler = artifact.DeleteArtifactHandlerFunc(func(params artifact.DeleteArtifactParams) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		if res := c.ArtifactAPI.Prepare(ctx, "DeleteArtifact", &params); res != nil {
			return res
		}
		return c.ArtifactAPI.DeleteArtifact(ctx, params)
	})
	api.RepositoryDeleteRepositoryHandler = repository.DeleteRepositoryHandlerFunc(func(params repository.DeleteRepositoryParams) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		if res := c.RepositoryAPI.Prepare(ctx, "DeleteRepository", &params); res != nil {
			return res
		}
		return c.RepositoryAPI.DeleteRepository(ctx, params)
	})
	api.ArtifactDeleteTagHandler = artifact.DeleteTagHandlerFunc(func(params artifact.DeleteTagParams) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		if res := c.ArtifactAPI.Prepare(ctx, "DeleteTag", &params); res != nil {
			return res
		}
		return c.ArtifactAPI.DeleteTag(ctx, params)
	})
	api.ArtifactGetAdditionHandler = artifact.GetAdditionHandlerFunc(func(params artifact.GetAdditionParams) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		if res := c.ArtifactAPI.Prepare(ctx, "GetAddition", &params); res != nil {
			return res
		}
		return c.ArtifactAPI.GetAddition(ctx, params)
	})
	api.ArtifactGetArtifactHandler = artifact.GetArtifactHandlerFunc(func(params artifact.GetArtifactParams) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		if res := c.ArtifactAPI.Prepare(ctx, "GetArtifact", &params); res != nil {
			return res
		}
		return c.ArtifactAPI.GetArtifact(ctx, params)
	})
	api.ProjectGetLogsHandler = project.GetLogsHandlerFunc(func(params project.GetLogsParams) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		if res := c.ProjectAPI.Prepare(ctx, "GetLogs", &params); res != nil {
			return res
		}
		return c.ProjectAPI.GetLogs(ctx, params)
	})
	api.ScanGetReportLogHandler = scan.GetReportLogHandlerFunc(func(params scan.GetReportLogParams) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		if res := c.ScanAPI.Prepare(ctx, "GetReportLog", &params); res != nil {
			return res
		}
		return c.ScanAPI.GetReportLog(ctx, params)
	})
	api.RepositoryGetRepositoryHandler = repository.GetRepositoryHandlerFunc(func(params repository.GetRepositoryParams) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		if res := c.RepositoryAPI.Prepare(ctx, "GetRepository", &params); res != nil {
			return res
		}
		return c.RepositoryAPI.GetRepository(ctx, params)
	})
	api.ArtifactListArtifactsHandler = artifact.ListArtifactsHandlerFunc(func(params artifact.ListArtifactsParams) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		if res := c.ArtifactAPI.Prepare(ctx, "ListArtifacts", &params); res != nil {
			return res
		}
		return c.ArtifactAPI.ListArtifacts(ctx, params)
	})
	api.AuditlogListAuditLogsHandler = auditlog.ListAuditLogsHandlerFunc(func(params auditlog.ListAuditLogsParams) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		if res := c.AuditlogAPI.Prepare(ctx, "ListAuditLogs", &params); res != nil {
			return res
		}
		return c.AuditlogAPI.ListAuditLogs(ctx, params)
	})
	api.RepositoryListRepositoriesHandler = repository.ListRepositoriesHandlerFunc(func(params repository.ListRepositoriesParams) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		if res := c.RepositoryAPI.Prepare(ctx, "ListRepositories", &params); res != nil {
			return res
		}
		return c.RepositoryAPI.ListRepositories(ctx, params)
	})
	api.ArtifactListTagsHandler = artifact.ListTagsHandlerFunc(func(params artifact.ListTagsParams) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		if res := c.ArtifactAPI.Prepare(ctx, "ListTags", &params); res != nil {
			return res
		}
		return c.ArtifactAPI.ListTags(ctx, params)
	})
	api.ArtifactRemoveLabelHandler = artifact.RemoveLabelHandlerFunc(func(params artifact.RemoveLabelParams) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		if res := c.ArtifactAPI.Prepare(ctx, "RemoveLabel", &params); res != nil {
			return res
		}
		return c.ArtifactAPI.RemoveLabel(ctx, params)
	})
	api.ScanScanArtifactHandler = scan.ScanArtifactHandlerFunc(func(params scan.ScanArtifactParams) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		if res := c.ScanAPI.Prepare(ctx, "ScanArtifact", &params); res != nil {
			return res
		}
		return c.ScanAPI.ScanArtifact(ctx, params)
	})
	api.RepositoryUpdateRepositoryHandler = repository.UpdateRepositoryHandlerFunc(func(params repository.UpdateRepositoryParams) middleware.Responder {
		ctx := params.HTTPRequest.Context()
		if res := c.RepositoryAPI.Prepare(ctx, "UpdateRepository", &params); res != nil {
			return res
		}
		return c.RepositoryAPI.UpdateRepository(ctx, params)
	})
	api.ServerShutdown = func() {}
	return api.Serve(c.InnerMiddleware), api, nil
}

// swaggerCopy copies the swagger json to prevent data races in runtime
func swaggerCopy(orig json.RawMessage) json.RawMessage {
	c := make(json.RawMessage, len(orig))
	copy(c, orig)
	return c
}

// authorizer is a helper function to implement the runtime.Authorizer interface.
type authorizer func(*http.Request) error

func (a authorizer) Authorize(req *http.Request, principal interface{}) error {
	if a == nil {
		return nil
	}
	ctx := storeAuth(req.Context(), principal)
	return a(req.WithContext(ctx))
}

func storeAuth(ctx context.Context, principal interface{}) context.Context {
	return context.WithValue(ctx, AuthKey, principal)
}
